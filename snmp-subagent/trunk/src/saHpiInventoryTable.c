/*
* (C) Copyright IBM Corp. 2003
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  This
 * file and program are licensed under a BSD style license.  See
 * the Copying file included with the OpenHPI distribution for
 * full licensing terms.
 *
 * Authors:
 *   Konrad Rzeszutek <konradr@us.ibm.com>
 *
 * Note: this file originally auto-generated by mib2c using
 *       : mib2c.array-user.conf,v 5.15.2.1 2003/02/27 05:59:41 rstory Exp $
 *
 * $Id$
 *
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include <net-snmp/library/snmp_assert.h>

#include <saHpiInventoryTable.h>
#include <hpiSubagent.h>

static netsnmp_handler_registration *my_handler = NULL;
static netsnmp_table_array_callbacks cb;


static oid saHpiInventoryTable_oid[] = { saHpiInventoryTable_TABLE_OID };
static size_t saHpiInventoryTable_oid_len =
OID_LENGTH (saHpiInventoryTable_oid);
static oid saHpiInventoryCount_oid[] = { hpiResources_OID, 7, 0 };

static u_long inventory_count = 0;

static int
delete_inventory_row (SaHpiDomainIdT, SaHpiResourceIdT, SaHpiEirIdT, long);


static void
update_context_on_inventory_data (SaHpiInventGeneralDataT *,
				  saHpiInventoryTable_context *);

static int
update_inventory_data_on_context (SaHpiInventGeneralDataT *,
				  saHpiInventoryTable_context *,
				  char *, size_t, size_t *);

static int
saHpiInventoryTable_modify_context (SaHpiEntryIdT rdr_id,
				    SaHpiInventoryRecT * entry,
				    SaHpiRptEntryT * rpt_entry,
				    long count,
				    SaHpiInventoryDataT * inv_data,
				    SaHpiUint32T inv_data_size,
				    oid * rdr_entry, size_t rdr_entry_oid_len,
				    saHpiInventoryTable_context * ctx);
int
populate_inventory (SaHpiEntryIdT rdr_id,
		    SaHpiInventoryRecT * inventory,
		    SaHpiRptEntryT * rpt_entry,
		    oid * rdr_entry_oid, size_t rdr_entry_oid_len,
		    oid * inventory_oid, size_t * inventory_oid_len)
{
  SaHpiSessionIdT session_id;
  SaHpiInventoryDataT *data = NULL;
  SaHpiUint32T data_len;
  size_t initial_size;

  int rc = AGENT_ERR_NOERROR;
  long stop;
  long count = 0;
  long count_of_items = 0;
  oid index_oid[INVENTORY_INDEX_NR];
  oid column[2];

  netsnmp_index inventory_index;
#ifdef BUG_873961
  netsnmp_void_array *array;
  int i = 0;
  saHpiInventoryTable_context *ctx = NULL;
#endif
  saHpiInventoryTable_context *inventory_context;
  saHpiInventoryTable_context *first_context = NULL;

  DEBUGMSGTL ((AGENT, "\n\t--- populate_inventory: Entry.\n"));

  if (inventory)
    {

      // Get Inventory Data -- from there we can the index value.
      rc = getSaHpiSession (&session_id);
      if (rc != AGENT_ERR_NOERROR)
	{
	  DEBUGMSGTL ((AGENT, "Call to getSaHpiSession failed with rc: %d\n",
		       rc));
	  return rc;
	}
      initial_size = 2 * (sizeof (SaHpiInventoryDataT) +
			  sizeof (SaHpiInventDataRecordT) +
			  sizeof (SaHpiTextBufferT) * TEXT_BUFFER_NUMBER);

    memory_fixed:

      data = malloc (initial_size);

      if (data == NULL)
	{
	  snmp_log (LOG_ERR, "saHpiInventoryTable: Not enough memory.\n");
	  return AGENT_ERR_MEMORY_FAULT;
	}

      memset (data, 0x00, initial_size);

      rc = saHpiEntityInventoryDataRead (session_id,
					 rpt_entry->ResourceId,
					 inventory->EirId,
					 initial_size, data, &data_len);

      if (rc == SA_ERR_INVENT_DATA_TRUNCATED)
	{
	  free (data);
	  data = NULL;
	  initial_size *= 2;
	  // MAXBUF is defined in hpiSubagent.h
	  if (initial_size > MAXBUF)
	    {
	      DEBUGMSGTL ((AGENT,
			   "Trying to allocate more memory than MAX definded (%d bytes).\n",
			   MAXBUF));
	      return AGENT_ERR_MEMORY_FAULT;
	    }
	  goto memory_fixed;
	}

      if (rc != SA_OK)
	{
	  snmp_log (LOG_WARNING,
		    "Call to saHpiEntityInventoryDataRead returns error code: %s.\n",
		    get_error_string (rc));
	  DEBUGMSGTL ((AGENT, "saHpiEntityInventoryDataRead rc is %s\n",
		       get_error_string (rc)));
	  free (data);
	  data = NULL;
	  return AGENT_ERR_OPERATION;
	}


      for (stop = SAHPI_FALSE, count = 0; stop != SAHPI_TRUE; count++)
	{

	  inventory_index.len = INVENTORY_INDEX_NR;
	  // Look at the MIB to find out what the indexs are
	  index_oid[0] = rpt_entry->DomainId;
	  index_oid[1] = rpt_entry->ResourceId;
	  index_oid[2] = inventory->EirId;
	  index_oid[3] = count;

	  inventory_index.oids = (oid *) & index_oid;

	  // We might be re-populating. Check for existing entries
	  inventory_context = NULL;
	  inventory_context = CONTAINER_FIND (cb.container, &inventory_index);
	  // If we don't find it - create it.
#ifdef BUG_873961
	  if (!inventory_context)
	  {
		  // Bug # 873961. We use the 'rdr_id' to check to see if
		  //  it is the context. To do so, we have to search fo
		  inventory_index.len = 1;
		  array = CONTAINER_GET_SUBSET (cb.container, &inventory_index);
		if (array != NULL) 
		{
			if (array->size > 0) 
			{
				for (i = 0; i < array->size; i++) 
				{
					ctx = array->array[i];
					if (ctx->rdr_id == rdr_id) 
					{
						// Found the duplicate entry!
						inventory_context = ctx;
						index_oid[1] = ctx->resource_id;
						index_oid[2] = ctx->saHpiInventoryEirId;
						index_oid[3] = ctx->saHpiInventoryIndex;
						DEBUGMSGTL((AGENT,
									"duplicate nventory entry %d, %d, %d, %d [rdr: %d] found.\n",
									rpt_entry->DomainId,
									rpt_entry->ResourceId,
									inventory->EirId,
									count,
									rdr_id));
						break;
					}
				}
			}
			free(array->array);
			free(array); array = NULL;
		}
		// restoree it to its previous glory.
		inventory_index.len =  INVENTORY_INDEX_NR;
	  }
#endif
	  if (!inventory_context)
	    {
	      // New entry.
	      inventory_context =
		saHpiInventoryTable_create_row (&inventory_index);
	    }
	  if (!inventory_context)
	    {
	      snmp_log (LOG_ERR, "Not enough memory for a inventory row!");
	      return AGENT_ERR_INTERNAL_ERROR;
	    }
	  // Remember the first inventory context - that's where we keep the count
	  // of sub-indexes.
	  if (first_context == NULL)
	    {
	      first_context = inventory_context;
	      // Generate our full OID and pass it up to 
	      // We are only generating it ONCE (the first time).
	      column[0] = 1;
	      column[1] = COLUMN_SAHPIINVENTORYEIRID;

	      build_full_oid (saHpiInventoryTable_oid,
			      saHpiInventoryTable_oid_len, column, 2,
			      &inventory_index, inventory_oid, MAX_OID_LEN,
			      inventory_oid_len);

	    }
	  DEBUGMSGTL ((AGENT, "%d: %d, %d (Validity: %d)\n", count,
		       (data->DataRecords[count] ==
			NULL) ? -1 : data->DataRecords[count]->RecordType,
		       (data->DataRecords[count] ==
			NULL) ? -1 : data->DataRecords[count]->DataLength,
		       data->Validity));

	  if (saHpiInventoryTable_modify_context (rdr_id,inventory,
						  rpt_entry,
						  count,
						  data, data_len,
						  rdr_entry_oid,
						  rdr_entry_oid_len,
						  inventory_context) ==
	      AGENT_NEW_ENTRY)
	    {
	      CONTAINER_INSERT (cb.container, inventory_context);
	      inventory_count = CONTAINER_SIZE (cb.container);
	    }

	  /* Bug 872437 segfault when populating inventory entries using snmp_bc
	   *
	   * This line below can segfault when using certain plugins that do *not*
	   * set the last entry to be NULL. Because they assume that there will be only
	   * one record data. Which would have been fine, except that the 'count+1' 
	   * resolves the to an address right smack in the data entries for the data.
	   * Thefore instead of finding a nice 0x0000..00 value, we get the values of 
	   * of the first item and end up crashing or looping forever. 
	   * Perhaps we should put some logic to detect that kind of situation, but
	   * why bother - this way the plugin writer finds an bug in his/her code.*/
	  DEBUGMSGTL((AGENT,"Approaching possible seg fault invocation. If the plugin was writen improperly this will crash the application."));
	  if (data->DataRecords[count+1] == NULL) 
	  { 
	    stop = SAHPI_TRUE;
	  }
	}			// End of loop. No more record changing/adding.

      // Just finish the data.
      free (data);
      data = NULL;

      // Check to see if the count is greater from what we have in memory
      if (count < first_context->count_of_subitems)
	{
	  // Oh no! Must delete some entries
	  // Warning: Re-using 'stop' variable
	  count_of_items = first_context->count_of_subitems;
	  // 'first_context' *MIGHT* be removed ,thus we would lose the number.
	  DEBUGMSGTL ((AGENT,
		       "Deleting Inventory Records: Number iterated thru: %d, Number that exist in memory: %d\n",
		       count, count_of_items));

	  for (stop = count; stop <= count_of_items; stop++)
	    {
	      delete_inventory_row (first_context->domain_id,
				    first_context->resource_id,
				    first_context->saHpiInventoryEirId, stop);
	    }

	}
      first_context->count_of_subitems = count;

      rc = AGENT_ERR_NOERROR;
    }				// if (inventory)
  else
    rc = AGENT_ERR_OPERATION;

  if (data != NULL)
    DEBUGMSGTL ((AGENT, "free != NULL, possible memory leak.\n"));

  DEBUGMSGTL ((AGENT, "\n\t--- populate_inventory. Exit\n"));
  return rc;

}

/*
 * Internal helper function to delete not-used rows.
 * 
 */
static int
delete_inventory_row (SaHpiDomainIdT domain_id,
		      SaHpiResourceIdT resource_id,
		      SaHpiEirIdT num, long count)
{
  saHpiInventoryTable_context *ctx;
  int rc = AGENT_ERR_NOT_FOUND;
  oid inv_oid[INVENTORY_INDEX_NR];
  netsnmp_index index;

  DEBUGMSGTL ((AGENT, "static delete_inventory_row (%d, %d, %d, %d) Entry.\n",
	       domain_id, resource_id, num, count));
  inv_oid[0] = domain_id;
  inv_oid[1] = resource_id;
  inv_oid[2] = num;
  inv_oid[3] = count;

  index.oids = (oid *) & inv_oid;
  index.len = INVENTORY_INDEX_NR;

  ctx = CONTAINER_FIND (cb.container, &index);

  if (ctx)
    {
      CONTAINER_REMOVE (cb.container, ctx);
      saHpiInventoryTable_delete_row (ctx);
      inventory_count = CONTAINER_SIZE (cb.container);
      rc = AGENT_ERR_NOERROR;
    }
  DEBUGMSGTL ((AGENT, "static delete_inventory_row. Exit (rc: %d)\n", rc));
  return rc;
}


/*
 * External function to delete rows.
 */
int
delete_inventory_rows (SaHpiDomainIdT domain_id,
		       SaHpiResourceIdT resource_id, SaHpiEirIdT num)
{
  saHpiInventoryTable_context *ctx;
  long i, count;
  int rc = AGENT_ERR_NOT_FOUND;
  oid inv_oid[INVENTORY_INDEX_NR];
  netsnmp_index index;

  DEBUGMSGTL ((AGENT, "delete_inventory_rows (%d, %d, %d). Entry\n",
	       domain_id, resource_id, num));

  inv_oid[0] = domain_id;
  inv_oid[1] = resource_id;
  inv_oid[2] = num;
  inv_oid[3] = 0;

  index.oids = (oid *) & inv_oid;
  index.len = INVENTORY_INDEX_NR;
  ctx = CONTAINER_FIND (cb.container, &index);

  if (ctx)
    {
      count = ctx->count_of_subitems;
      // Go thru all rows 
      for (i = 0; i <= count; i++)
	{
	  delete_inventory_row (domain_id, resource_id, num, i);
	}
      rc = AGENT_ERR_NOERROR;
    }
  DEBUGMSGTL ((AGENT, "delete_inventory_rows. Exit (rc: %d)\n", rc));
  return rc;

}

int
saHpiInventoryTable_modify_context (SaHpiEntryIdT rdr_id,
				    SaHpiInventoryRecT * entry,
				    SaHpiRptEntryT * rpt_entry,
				    long count,
				    SaHpiInventoryDataT * inv_data,
				    SaHpiUint32T inv_data_size,
				    oid * rdr_entry, size_t rdr_entry_oid_len,
				    saHpiInventoryTable_context * ctx)
{
  unsigned int update_entry = MIB_FALSE;
  long hash;
  SaHpiInventDataRecordT data;
  long len;
  integer64 time_attr;

  if (entry && ctx)
    {

      // We are subtracting SaHpiTextBufferT b/c the underlaying HPI
      // library is not zeroing out the memory for not used entries -
      // thus garbage in SaHpiTextBufferT exist,
      hash = calculate_hash_value (entry, sizeof (SaHpiInventoryRecT));

      DEBUGMSGTL ((AGENT, " Hash value: %d, in ctx: %d\n", hash, ctx->hash));

      if (ctx->hash != 0)
	{
	  // Only do the check if the hash value is something else than zero.
	  // 'zero' value is only for newly created records, and in some
	  // rare instances when the hash has rolled to zero - in which
	  // case we will just consider the worst-case scenario and update
	  // the record and not trust the hash value.
	  if (hash == ctx->hash)
	    {
	      // The same data. No need to change.
	      return AGENT_ENTRY_EXIST;
	    }
	  if (((ctx->resource_id == rpt_entry->ResourceId) && 
	      (ctx->domain_id == rpt_entry->DomainId) &&
	      (ctx->saHpiInventoryEirId == entry->EirId) &&
	      (ctx->saHpiInventoryIndex == count)) || 
	      (ctx->rdr_id == rdr_id)) {
		  DEBUGMSGTL((AGENT,"Updating inventory entry [%d, %d, %d, %d]\n",
					  rpt_entry->DomainId,
					  rpt_entry->ResourceId,
					  entry->EirId,
					  count));
		  update_entry = MIB_TRUE;
	    }
	}

      if (hash == 0)
	hash = 1;
      ctx->hash = hash;

      ctx->resource_id = rpt_entry->ResourceId;
      ctx->domain_id = rpt_entry->DomainId;
      ctx->rdr_id = rdr_id;
      ctx->saHpiInventoryRDR_len = rdr_entry_oid_len * sizeof (oid);
      memcpy (ctx->saHpiInventoryRDR, rdr_entry, ctx->saHpiInventoryRDR_len);
      ctx->saHpiInventoryEirId = entry->EirId;
      ctx->saHpiInventoryIndex = count;
      ctx->saHpiInventoryOEM = entry->Oem;

      ctx->saHpiInventoryAttributes_len = 0;
      memset (ctx->saHpiInventoryAttributes, 0x00,
	      SAHPI_INVENTORY_ATTRIBUTES_MAX);
      ctx->saHpiInventoryManufacturer_len = 0;
      ctx->saHpiInventoryProductName_len = 0;
      ctx->saHpiInventoryProductVersion_len = 0;
      ctx->saHpiInventoryModelNumber_len = 0;
      ctx->saHpiInventorySerialNumber_len = 0;
      ctx->saHpiInventoryPartNumber_len = 0;
      ctx->saHpiInventoryFileId_len = 0;
      ctx->saHpiInventoryAssetTag_len = 0;
      ctx->saHpiInventoryCustomField_len = 0;
      ctx->saHpiInventoryTextType = 0;
      ctx->saHpiInventoryTextLanguage = 0;

      ctx->saHpiInventoryValidity = MIB_INVALID;

      if (inv_data->DataRecords[count])
	{
	  data = *(inv_data->DataRecords[count]);
	  switch (inv_data->Validity)
	    {
	    case SAHPI_INVENT_DATA_VALID:
	      ctx->saHpiInventoryValidity = MIB_VALID;
	      break;
	    case SAHPI_INVENT_DATA_INVALID:
	      ctx->saHpiInventoryValidity = MIB_INVALID;
	      break;
	    case SAHPI_INVENT_DATA_OVERFLOW:
	      ctx->saHpiInventoryValidity = MIB_OVERFLOW;
	      break;
	    default:
	      ctx->saHpiInventoryValidity = MIB_UNDEFINED;
	    }

	  // If we receive data-record that is invalid, these entries are
	  // still safe - but the data might be corrupted - *unless* you
	  // memset to 0x00 before you put data in it.
	  ctx->saHpiInventoryRecordType = data.RecordType+1;

	  switch (data.RecordType)
	    {
	    case SAHPI_INVENT_RECTYPE_INTERNAL_USE:
		
	      ctx->saHpiInventoryAttributes_len =
		(data.DataLength <
		 SAHPI_INVENTORY_ATTRIBUTES_MAX) ? data.
		DataLength  : SAHPI_INVENTORY_ATTRIBUTES_MAX;

		/* Copy variable data. */
	      memcpy (ctx->saHpiInventoryAttributes+ sizeof (SaHpiUint32T),
		      data.RecordData.InternalUse.Data, data.DataLength);
	      break;
	    case SAHPI_INVENT_RECTYPE_CHASSIS_INFO:
	      /* Add +1 (MIB CR: #55) and normalize */
	      data.RecordData.ChassisInfo.Type = htonl(data.RecordData.ChassisInfo.Type+1);
	      memcpy (ctx->saHpiInventoryAttributes,
		      &data.RecordData.ChassisInfo.Type,
		      sizeof(SaHpiInventChassisTypeT));
	      /* Normalize the Time. */

              time_attr.low = data.RecordData.ChassisInfo.GeneralData.MfgDateTime & 0xffffffff;
              time_attr.high = data.RecordData.ChassisInfo.GeneralData.MfgDateTime >> 32;

	      /* Convert to network byte order */
	      time_attr.low = htonl(time_attr.low);
	      time_attr.high = htonl(time_attr.high);

	      ctx->saHpiInventoryAttributes_len +=  sizeof (SaHpiTimeT);
	      memcpy (ctx->saHpiInventoryAttributes + sizeof(SaHpiInventChassisTypeT),
		      &time_attr,
		      sizeof (SaHpiTimeT));

	      /* Copy the rest of the objects */
	      update_context_on_inventory_data (&data.RecordData.ChassisInfo.
						GeneralData, ctx);
	      break;
	    case SAHPI_INVENT_RECTYPE_BOARD_INFO:
	      ctx->saHpiInventoryAttributes_len = sizeof (SaHpiTimeT);

              time_attr.low = data.RecordData.BoardInfo.MfgDateTime & 0xffffffff;
              time_attr.high = data.RecordData.BoardInfo.MfgDateTime >> 32;
	      /* Convert to network byte order */
	      time_attr.low = htonl(time_attr.low);
	      time_attr.high = htonl(time_attr.high);
	      memcpy (ctx->saHpiInventoryAttributes,
		      &time_attr,
		      sizeof (SaHpiTimeT));

	      update_context_on_inventory_data (&data.RecordData.BoardInfo,
						ctx);
	      break;
	    case SAHPI_INVENT_RECTYPE_PRODUCT_INFO:
	      ctx->saHpiInventoryAttributes_len = sizeof (SaHpiTimeT);
	      /* Normalize the value as two 32 bit longs */
              time_attr.low = data.RecordData.ProductInfo.MfgDateTime & 0xffffffff;
              time_attr.high = data.RecordData.ProductInfo.MfgDateTime >> 32;
	      /* Convert to network byte order */
	      time_attr.low = htonl(time_attr.low);
	      time_attr.high = htonl(time_attr.high);

	      memcpy (ctx->saHpiInventoryAttributes,
		      &time_attr,
		      sizeof (SaHpiTimeT));

	      update_context_on_inventory_data (&data.RecordData.ProductInfo,
						ctx);
	      break;
	    case SAHPI_INVENT_RECTYPE_OEM:

	      ctx->saHpiInventoryAttributes_len =
		sizeof (SaHpiManufacturerIdT);
		/* Convert to network order */
	      data.RecordData.OemData.MId =
		htonl (data.RecordData.OemData.MId);
	      memcpy (ctx->saHpiInventoryAttributes,
		      &data.RecordData.OemData.MId,
		      sizeof (SaHpiManufacturerIdT));

	      /* It ought to be only 1 byte of data, but you never know. */
	      len = ((data.DataLength + sizeof (SaHpiManufacturerIdT)) >
		     SAHPI_INVENTORY_ATTRIBUTES_MAX) ?
		SAHPI_INVENTORY_ATTRIBUTES_MAX :
		(data.DataLength + sizeof (SaHpiManufacturerIdT));
	 	/* Copying the variable length data */
	      memcpy (ctx->saHpiInventoryAttributes +
		      ctx->saHpiInventoryAttributes_len,
		      &data.RecordData.OemData.Data, len);
	      ctx->saHpiInventoryAttributes_len = len;
	      break;
	    default:
	      break;
	    }

	}
      if (update_entry == MIB_TRUE)
	      return AGENT_ENTRY_EXIST;
      return AGENT_NEW_ENTRY;
    }

  return AGENT_ERR_NULL_DATA;

}

void
update_context_on_inventory_data (SaHpiInventGeneralDataT * data,
				  saHpiInventoryTable_context * ctx)
{

  // IBM-KR: Possible MIB change 

  if (data->Manufacturer)
    {
      ctx->saHpiInventoryTextType = data->Manufacturer->DataType + 1;
      ctx->saHpiInventoryTextLanguage = data->Manufacturer->Language +1 ;

      ctx->saHpiInventoryManufacturer_len = data->Manufacturer->DataLength;
      memcpy (ctx->saHpiInventoryManufacturer, data->Manufacturer->Data,
	      ctx->saHpiInventoryManufacturer_len);
    }
  if (data->ProductName)
    {
      ctx->saHpiInventoryProductName_len = data->ProductName->DataLength;
      memcpy (ctx->saHpiInventoryProductName, data->ProductName->Data,
	      ctx->saHpiInventoryProductName_len);
    }

  if (data->ProductVersion)
    {
      ctx->saHpiInventoryProductVersion_len =
	data->ProductVersion->DataLength;
      memcpy (ctx->saHpiInventoryProductVersion, data->ProductVersion->Data,
	      ctx->saHpiInventoryProductVersion_len);
    }

  if (data->ModelNumber)
    {
      ctx->saHpiInventoryModelNumber_len = data->ModelNumber->DataLength;
      memcpy (ctx->saHpiInventoryModelNumber, data->ModelNumber->Data,
	      ctx->saHpiInventoryModelNumber_len);
    }

  if (data->SerialNumber)
    {
      ctx->saHpiInventorySerialNumber_len = data->SerialNumber->DataLength;
      memcpy (ctx->saHpiInventorySerialNumber, data->SerialNumber->Data,
	      ctx->saHpiInventorySerialNumber_len);
    }
  if (data->PartNumber)
    {
      ctx->saHpiInventoryPartNumber_len = data->PartNumber->DataLength;
      memcpy (ctx->saHpiInventoryPartNumber, data->PartNumber->Data,
	      ctx->saHpiInventoryPartNumber_len);
    }

  if (data->FileId)
    {
      ctx->saHpiInventoryFileId_len = data->FileId->DataLength;
      memcpy (ctx->saHpiInventoryFileId, data->FileId->Data,
	      ctx->saHpiInventoryFileId_len);
    }

  if (data->AssetTag)
    {
      ctx->saHpiInventoryAssetTag_len = data->AssetTag->DataLength;
      memcpy (ctx->saHpiInventoryAssetTag, data->AssetTag->Data,
	      ctx->saHpiInventoryAssetTag_len);
    }

  // Should be how many?
  // IBM-KR: MIB and implementation restriction. We only have *ONE* CustomField;
  // there could be more...
  if (data->CustomField[0])
    {
      ctx->saHpiInventoryCustomField_len = data->CustomField[0]->DataLength;
      memcpy (ctx->saHpiInventoryCustomField, data->CustomField[0]->Data,
	      ctx->saHpiInventoryCustomField_len);
    }
}

static SaHpiTextBufferT *
copy_data (saHpiInventoryTable_context * ctx,
	   unsigned char *data, int length,
	   char *mem_location, size_t max_size, size_t * new_size)
{

  SaHpiTextBufferT *buf = NULL;
  register int l;
  if (length == 0)
    return NULL;

  l = length + sizeof (SaHpiTextTypeT) +
    sizeof (SaHpiLanguageT) + sizeof (SaHpiUint8T);

  DEBUGMSGTL ((AGENT,
	       "Length is : %d, (total: %d) (left bytes in memory hole: %d)\n",
	       length, l, max_size));
  if (l > max_size)
    return NULL;
  buf = (SaHpiTextBufferT *) mem_location;

  if (buf == NULL)
    {
      return NULL;
    }

  memset (buf, 0x00, l);
  buf->DataType = ctx->saHpiInventoryTextType - 1;
  buf->Language = ctx->saHpiInventoryTextLanguage - 1;
  buf->DataLength = length;

  memcpy (buf->Data, data, length);

  *new_size += l;

  DEBUGMSGTL ((AGENT, "-- Copied data  at %X (size: %d), new_size is: %d\n",
	       buf, l, *new_size));
  return buf;
}

static int
update_inventory_data_on_context (SaHpiInventGeneralDataT * gen_data,
				  saHpiInventoryTable_context * ctx,
				  char *data,
				  size_t max_octets, size_t * length)
{

  //  SaHpiTextBufferT *buf =NULL;
  // Memory start point is at:
  // initial_length.
  gen_data->Manufacturer = copy_data (ctx, ctx->saHpiInventoryManufacturer,
				      ctx->saHpiInventoryManufacturer_len,
				      (char *) data, max_octets, length);

  gen_data->ProductName = copy_data (ctx, ctx->saHpiInventoryProductName,
				     ctx->saHpiInventoryProductName_len,
				     (char *) data + *length,
				     max_octets - *length, length);

  gen_data->ProductVersion =
    copy_data (ctx, ctx->saHpiInventoryProductVersion,
	       ctx->saHpiInventoryProductVersion_len, (char *) data + *length,
	       max_octets - *length, length);

  gen_data->ModelNumber = copy_data (ctx, ctx->saHpiInventoryModelNumber,
				     ctx->saHpiInventoryModelNumber_len,
				     (char *) data + *length,
				     max_octets - *length, length);

  gen_data->SerialNumber = copy_data (ctx, ctx->saHpiInventorySerialNumber,
				      ctx->saHpiInventorySerialNumber_len,
				      (char *) data + *length,
				      max_octets - *length, length);

  gen_data->PartNumber = copy_data (ctx, ctx->saHpiInventoryPartNumber,
				    ctx->saHpiInventoryPartNumber_len,
				    (char *) data + *length,
				    max_octets - *length, length);

  gen_data->FileId = copy_data (ctx, ctx->saHpiInventoryFileId,
				ctx->saHpiInventoryFileId_len,
				(char *) data + *length, max_octets - *length,
				length);

  gen_data->AssetTag = copy_data (ctx, ctx->saHpiInventoryAssetTag,
				  ctx->saHpiInventoryAssetTag_len,
				  (char *) data + *length,
				  max_octets - *length, length);

  gen_data->CustomField[0] = copy_data (ctx, ctx->saHpiInventoryCustomField,
					ctx->saHpiInventoryCustomField_len,
					(char *) data + *length,
					max_octets - *length, length);

  return AGENT_ERR_NOERROR;

}

int
set_inventory (saHpiInventoryTable_context * ctx)
{


  SaHpiSessionIdT session_id;
  SaHpiInventDataRecordT *data_rec;
  SaHpiUint32T length = 0;
  SaErrorT rc = SA_OK;


  SaHpiInventoryDataT *data = NULL;
  size_t initial_size;
  SaHpiUint32T data_len;
  integer64 time_attr;

  if (ctx)
    {

      // First we retrieve the inventory item - then we
      // will modify the right context.

      // Our max:  9*sizeof(SaHpiTextBuffer)+ SAHPI_INVENTORY_ATTRIBUTES_MAX + sizeof(SaHpiInventoryDataT)

      rc = getSaHpiSession (&session_id);
      if (rc != AGENT_ERR_NOERROR)
	return rc;

      initial_size = sizeof (SaHpiInventoryDataT) +
	sizeof (SaHpiTextBufferT) * 9 +
	SAHPI_INVENTORY_ATTRIBUTES_MAX + sizeof (SaHpiInventDataRecordT);

    memory_fixed:

      data = malloc (initial_size);

      if (data == NULL)
	{
	  snmp_log (LOG_ERR, "Not enough memory to allocate: %d\n",
		    initial_size);
	  return AGENT_ERR_MEMORY_FAULT;
	}

      memset (data, 0x00, initial_size);

      DEBUGMSGTL ((AGENT,
		   "Calling saHpiEntityInventoryDataRead with buffer size %d\n",
		   initial_size));
      rc =
	saHpiEntityInventoryDataRead (session_id, ctx->resource_id,
				      ctx->saHpiInventoryEirId, initial_size,
				      data, &data_len);

      if (rc == SA_ERR_INVENT_DATA_TRUNCATED)
	{

	  free (data);
	  data = NULL;
	  initial_size *= 2;
	  DEBUGMSGTL ((AGENT,
		       "Data is truncated. requesting %d (and if its < %d)\n",
		       initial_size, MAXBUF));
	  if (initial_size > MAXBUF)
	    {
	      // Just some random limitation.
	      DEBUGMSGTL ((AGENT,
			   "Trying to allocate more memory than MAX definded (%d bytes).\n",
			   MAXBUF));
	      return AGENT_ERR_MEMORY_FAULT;
	    }
	  goto memory_fixed;
	}

      if (rc != SA_OK)
	{
	  snmp_log (LOG_WARNING,
		    "Call to saHpiEntityInventoryDataRead returns error code: %s.\n",
		    get_error_string (rc));
	  DEBUGMSGTL ((AGENT, "SaHpiEntityInventoryDataRead rc is %s\n",
		       get_error_string (rc)));
	  free (data);
	  data = NULL;
	  return AGENT_ERR_OPERATION;
	}

      // The 'data_len' and 'initial_size' tell us how much memory we have to stick our information in.
      // Check to see if its enough?
      // 8*255 + SNMP_MAX_MSG_SIZE

      if ((initial_size - data_len) <
	  (SNMP_MAX_MSG_SIZE + 9 * SAHPI_STRING_MAX))
	{
	  // Not enough space.
	  DEBUGMSGTL ((AGENT, "Initial: %d, data_len: %d, our request: %d\n",
		       initial_size, data_len,
		       (SNMP_MAX_MSG_SIZE + 9 * SAHPI_STRING_MAX)));
	  free (data);
	  data = NULL;
	  initial_size *= 2;
	  DEBUGMSGTL ((AGENT, "Need more memory: %d. Requesting\n",
		       initial_size));
	  goto memory_fixed;
	}

      // Set the pointer to modify the right SaHpiInventDataRecordT
      data_rec = data->DataRecords[ctx->saHpiInventoryIndex];
      if (data_rec == NULL)
	{
	  // Can't update NULL records.
	  free (data);
	  data = NULL;
	  snmp_log (LOG_WARNING,
		    "Trying to update null inventory records.\n");
	  DEBUGMSGTL ((AGENT, "InventoryRecord at that sub-index is NULL\n"));
	  return AGENT_ERR_OPERATION;
	}
      // We have a GO

      /* We 'assume' (this could be dangerous) that since the 
      	record is not NULL all the data that is given (for example
      	some of the SaHpiTextBufferT* data is within the 'data_len'  (in our
        memory hole).
        Therefore, for our records we will use the memory location
        past 'data_len' (memory hole) to store our entries. We know we have enough
        space for 8*255 + SNMP_MAX_MSG_SIZE octets (we have did our calculation 
        and size testing before giving the space to the SaHpi call). */

      data_rec->RecordType = ctx->saHpiInventoryRecordType-1;
      switch (data_rec->RecordType)
	{
	case SAHPI_INVENT_RECTYPE_INTERNAL_USE:

		length = ctx->saHpiInventoryAttributes_len;
		DEBUGMSGTL((AGENT,"This instruction might seg-fault the program. This is due unclear SAF spec."));
	/* Lastly copy the data */
	 	memcpy (ctx->saHpiInventoryAttributes+sizeof(SaHpiUint32T),
		 	&data_rec->RecordData.InternalUse.Data,
		 	length);
	  break;
	case SAHPI_INVENT_RECTYPE_CHASSIS_INFO:
	/*
	Copy the data and convert back to host order */
	memcpy (ctx->saHpiInventoryAttributes,
	  	&data_rec->RecordData.ChassisInfo.Type,
		sizeof(SaHpiInventChassisTypeT));
	
	data_rec->RecordData.ChassisInfo.Type = ntohl(data_rec->RecordData.ChassisInfo.Type)-1;

	length = sizeof(SaHpiInventChassisTypeT);
	/* Copy the manufacturer date. */
	  memcpy (&time_attr,
		  ctx->saHpiInventoryAttributes + sizeof(SaHpiInventChassisTypeT), sizeof (SaHpiTimeT));
	  length += sizeof (SaHpiTimeT);

	/* Convert back to our host type */

	data_rec->RecordData.ChassisInfo.GeneralData.MfgDateTime = time_attr.high;
	data_rec->RecordData.ChassisInfo.GeneralData.MfgDateTime = 
		data_rec->RecordData.ChassisInfo.GeneralData.MfgDateTime << 32;
	data_rec->RecordData.ChassisInfo.GeneralData.MfgDateTime += time_attr.low;
	
	 /* The location where pointer information will be stored is:
	   start address of data + 'data_len'. */
	  rc =
	    update_inventory_data_on_context (&data_rec->RecordData.
					      ChassisInfo.GeneralData, ctx,
					      (char *) data + data_len,
					      initial_size - data_len,
					      &length);
	  break;
	case SAHPI_INVENT_RECTYPE_BOARD_INFO:

	/* Copy the manufacturere date. */
	
	  memcpy (&time_attr,
		  ctx->saHpiInventoryAttributes, sizeof (SaHpiTimeT));
	  length = sizeof (SaHpiTimeT);
	/* Convert back to our host type */

	data_rec->RecordData.BoardInfo.MfgDateTime = time_attr.high;
	data_rec->RecordData.BoardInfo.MfgDateTime = 
		data_rec->RecordData.BoardInfo.MfgDateTime << 32;
	data_rec->RecordData.BoardInfo.MfgDateTime += time_attr.low;

	  rc =
	    update_inventory_data_on_context (&data_rec->RecordData.BoardInfo,
					      ctx, data_len + (char *) data,
					      initial_size - data_len,
					      &length);
	  break;
	case SAHPI_INVENT_RECTYPE_PRODUCT_INFO:
	  memcpy (&time_attr,
		  ctx->saHpiInventoryAttributes, sizeof (SaHpiTimeT));
	  length = sizeof (SaHpiTimeT);
	/* Convert back to our host type */

	data_rec->RecordData.ProductInfo.MfgDateTime = time_attr.high;
	data_rec->RecordData.ProductInfo.MfgDateTime = 
		data_rec->RecordData.ProductInfo.MfgDateTime << 32;
	data_rec->RecordData.ProductInfo.MfgDateTime += time_attr.low;

	  rc =
	    update_inventory_data_on_context (&data_rec->RecordData.
					      ProductInfo, ctx,
					      data_len + (char *) data,
					      initial_size - data_len,
					      &length);
	  break;
	case SAHPI_INVENT_RECTYPE_OEM:
	  /* This is iffy. The spec mentions that OemData.Data is just one
	   byte, but in the comment it mentions opaque variable lenght data.
	   Go figure :-( */

	  memcpy (&data_rec->RecordData.OemData.MId,
		  ctx->saHpiInventoryAttributes,
		  sizeof (SaHpiManufacturerIdT));
	 /* Convert back to host order */
	  data_rec->RecordData.OemData.MId =
	    ntohl (data_rec->RecordData.OemData.MId);

	  length = sizeof (SaHpiManufacturerIdT);

	  /* We copy n-bytes of the field. */

	  memcpy (&data_rec->RecordData.OemData.Data,
		  ctx->saHpiInventoryAttributes +  length,
		  ctx->saHpiInventoryAttributes_len - length);

	  length = ctx->saHpiInventoryAttributes_len;

	  break;
	default:
	  return AGENT_ERR_NULL_DATA;
	  break;
	}

      //  The 'rc' is from the 'update_inventory_...
      if (rc != AGENT_ERR_NOERROR)
	{
	  free (data);
	  data = NULL;
	  DEBUGMSGTL ((AGENT,
		       "update_inventory_data_on_context had an error: %d.\n",
		       rc));
	  return AGENT_ERR_MEMORY_FAULT;
	}

      data_rec->DataLength = length;


      DEBUGMSGTL ((AGENT, "Data is type: %d with length : %d; ",
		   data_rec->RecordType, data_rec->DataLength));

      // Get the seesion_id
      rc = getSaHpiSession (&session_id);
      if (rc != AGENT_ERR_NOERROR)
	return rc;

      rc = saHpiEntityInventoryDataWrite (session_id,
					  ctx->resource_id,
					  ctx->saHpiInventoryEirId, data);
      if (rc != SA_OK)
	{
	  snmp_log (LOG_WARNING,
		    "Call to saHpiEntityInventoryDataWrite returns error code: %d\n",
		    rc);
	  DEBUGMSGTL ((AGENT,
		       "saHpiEntityInventoryDataWrite return code is %d\n",
		       rc));
	  return AGENT_ERR_OPERATION;
	}
      free (data);
      data = NULL;

      return AGENT_ERR_NOERROR;
    }
  return AGENT_ERR_NULL_DATA;
}


/************************************************************
 * the *_row_copy routine
 */
static int
saHpiInventoryTable_row_copy (saHpiInventoryTable_context * dst,
			      saHpiInventoryTable_context * src)
{
  if (!dst || !src)
    return 1;

  /*
   * copy index, if provided
   */
  if (dst->index.oids)
    free (dst->index.oids);
  if (snmp_clone_mem ((void *) &dst->index.oids, src->index.oids,
		      src->index.len * sizeof (oid)))
    {
      dst->index.oids = NULL;
      return 1;
    }
  dst->index.len = src->index.len;


  /*
   * copy components into the context structure
   */
  dst->saHpiInventoryEirId = src->saHpiInventoryEirId;

  dst->saHpiInventoryIndex = src->saHpiInventoryIndex;

  dst->saHpiInventoryRecordType = src->saHpiInventoryRecordType;

  dst->saHpiInventoryValidity = src->saHpiInventoryValidity;

  memcpy (dst->saHpiInventoryAttributes, src->saHpiInventoryAttributes,
	  src->saHpiInventoryAttributes_len);
  dst->saHpiInventoryAttributes_len = src->saHpiInventoryAttributes_len;

  dst->saHpiInventoryTextType = src->saHpiInventoryTextType;

  dst->saHpiInventoryTextLanguage = src->saHpiInventoryTextLanguage;

  memcpy (dst->saHpiInventoryManufacturer,
	  src->saHpiInventoryManufacturer,
	  src->saHpiInventoryManufacturer_len);
  dst->saHpiInventoryManufacturer_len = src->saHpiInventoryManufacturer_len;

  memcpy (dst->saHpiInventoryProductName, src->saHpiInventoryProductName,
	  src->saHpiInventoryProductName_len);
  dst->saHpiInventoryProductName_len = src->saHpiInventoryProductName_len;

  memcpy (dst->saHpiInventoryProductVersion,
	  src->saHpiInventoryProductVersion,
	  src->saHpiInventoryProductVersion_len);
  dst->saHpiInventoryProductVersion_len =
    src->saHpiInventoryProductVersion_len;

  memcpy (dst->saHpiInventoryModelNumber, src->saHpiInventoryModelNumber,
	  src->saHpiInventoryModelNumber_len);
  dst->saHpiInventoryModelNumber_len = src->saHpiInventoryModelNumber_len;

  memcpy (dst->saHpiInventorySerialNumber,
	  src->saHpiInventorySerialNumber,
	  src->saHpiInventorySerialNumber_len);
  dst->saHpiInventorySerialNumber_len = src->saHpiInventorySerialNumber_len;

  memcpy (dst->saHpiInventoryPartNumber, src->saHpiInventoryPartNumber,
	  src->saHpiInventoryPartNumber_len);
  dst->saHpiInventoryPartNumber_len = src->saHpiInventoryPartNumber_len;

  memcpy (dst->saHpiInventoryFileId, src->saHpiInventoryFileId,
	  src->saHpiInventoryFileId_len);
  dst->saHpiInventoryFileId_len = src->saHpiInventoryFileId_len;

  memcpy (dst->saHpiInventoryAssetTag, src->saHpiInventoryAssetTag,
	  src->saHpiInventoryAssetTag_len);
  dst->saHpiInventoryAssetTag_len = src->saHpiInventoryAssetTag_len;

  memcpy (dst->saHpiInventoryCustomField, src->saHpiInventoryCustomField,
	  src->saHpiInventoryCustomField_len);
  dst->saHpiInventoryCustomField_len = src->saHpiInventoryCustomField_len;

  dst->saHpiInventoryOEM = src->saHpiInventoryOEM;

  memcpy (src->saHpiInventoryRDR, dst->saHpiInventoryRDR,
	  src->saHpiInventoryRDR_len);
  dst->saHpiInventoryRDR_len = src->saHpiInventoryRDR_len;

  dst->resource_id = src->resource_id;
  dst->domain_id = src->domain_id;
  dst->hash = src->hash;
  dst->count_of_subitems = src->count_of_subitems;

  return 0;
}



/*
 * the *_extract_index routine
 */
int
saHpiInventoryTable_extract_index (saHpiInventoryTable_context * ctx,
				   netsnmp_index * hdr)
{
  /*
   * temporary local storage for extracting oid index
   */
  netsnmp_variable_list var_saHpiDomainID;
  netsnmp_variable_list var_saHpiResourceID;
  netsnmp_variable_list var_saHpiInventoryEirId;
  netsnmp_variable_list var_saHpiInventoryIndex;
  int err;

  /*
   * copy index, if provided
   */
  if (hdr)
    {
      netsnmp_assert (ctx->index.oids == NULL);
      if (snmp_clone_mem ((void *) &ctx->index.oids, hdr->oids,
			  hdr->len * sizeof (oid)))
	{
	  return -1;
	}
      ctx->index.len = hdr->len;
    }

    /**
     * Create variable to hold each component of the index
     */

  memset (&var_saHpiDomainID, 0x00, sizeof (var_saHpiDomainID));
  var_saHpiDomainID.type = ASN_UNSIGNED;
  var_saHpiDomainID.next_variable = &var_saHpiResourceID;

  memset (&var_saHpiResourceID, 0x00, sizeof (var_saHpiResourceID));
  var_saHpiResourceID.type = ASN_UNSIGNED;
  var_saHpiResourceID.next_variable = &var_saHpiInventoryEirId;

  memset (&var_saHpiInventoryEirId, 0x00, sizeof (var_saHpiInventoryEirId));
  var_saHpiInventoryEirId.type = ASN_UNSIGNED;
  var_saHpiInventoryEirId.next_variable = &var_saHpiInventoryIndex;

  memset (&var_saHpiInventoryIndex, 0x00, sizeof (var_saHpiInventoryIndex));
  var_saHpiInventoryIndex.type = ASN_UNSIGNED;
  var_saHpiInventoryIndex.next_variable = NULL;


  /*
   * parse the oid into the individual components
   */
  err = parse_oid_indexes (hdr->oids, hdr->len, &var_saHpiDomainID);
  if (err == SNMP_ERR_NOERROR)
    {
      /*
       * copy components into the context structure
       */
      ctx->saHpiInventoryEirId = *var_saHpiInventoryEirId.val.integer;
      ctx->saHpiInventoryIndex = *var_saHpiInventoryIndex.val.integer;
    }

  /*
   * parsing may have allocated memory. free it.
   */
  snmp_reset_var_buffers (&var_saHpiDomainID);

  return err;
}

/************************************************************
 * the *_can_delete routine is called to determine if a row
 * can be deleted.
 *
 * return 1 if the row can be deleted
 * return 0 if the row cannot be deleted
 */
int
saHpiInventoryTable_can_delete (saHpiInventoryTable_context * undo_ctx,
				saHpiInventoryTable_context * row_ctx,
				netsnmp_request_group * rg)
{

  return 1;
}


/************************************************************
 * the *_create_row routine is called by the table handler
 * to create a new row for a given index. If you need more
 * information (such as column values) to make a decision
 * on creating rows, you must create an initial row here
 * (to hold the column values), and you can examine the
 * situation in more detail in the *_set_reserve1 or later
 * states of set processing. Simple check for a NULL undo_ctx
 * in those states and do detailed creation checking there.
 *
 * returns a newly allocated saHpiInventoryTable_context
 *   structure if the specified indexes are not illegal
 * returns NULL for errors or illegal index values.
 */
saHpiInventoryTable_context *
saHpiInventoryTable_create_row (netsnmp_index * hdr)
{
  saHpiInventoryTable_context *ctx =
    SNMP_MALLOC_TYPEDEF (saHpiInventoryTable_context);
  if (!ctx)
    return NULL;


  if (saHpiInventoryTable_extract_index (ctx, hdr))
    {
      free (ctx->index.oids);
      free (ctx);
      return NULL;
    }

  ctx->saHpiInventoryAttributes_len = 0;
  ctx->saHpiInventoryTextType = 0;
  ctx->saHpiInventoryTextLanguage = 0;
  ctx->saHpiInventoryManufacturer_len = 0;
  ctx->saHpiInventoryProductName_len = 0;
  ctx->saHpiInventoryProductVersion_len = 0;
  ctx->saHpiInventoryModelNumber_len = 0;
  ctx->saHpiInventorySerialNumber_len = 0;
  ctx->saHpiInventoryPartNumber_len = 0;
  ctx->saHpiInventoryFileId_len = 0;
  ctx->saHpiInventoryAssetTag_len = 0;
  ctx->saHpiInventoryCustomField_len = 0;
  ctx->hash = 0;
  ctx->count_of_subitems = 0;
  return ctx;
}


/************************************************************
 * the *_duplicate row routine
 */
saHpiInventoryTable_context *
saHpiInventoryTable_duplicate_row (saHpiInventoryTable_context * row_ctx)
{
  saHpiInventoryTable_context *dup;

  if (!row_ctx)
    return NULL;

  dup = SNMP_MALLOC_TYPEDEF (saHpiInventoryTable_context);
  if (!dup)
    return NULL;

  if (saHpiInventoryTable_row_copy (dup, row_ctx))
    {
      free (dup);
      dup = NULL;
    }

  return dup;
}

/************************************************************
 * the *_delete_row method is called to delete a row.
 */
netsnmp_index *
saHpiInventoryTable_delete_row (saHpiInventoryTable_context * ctx)
{


  if (ctx->index.oids)
    free (ctx->index.oids);


  /*
   * release header
   */
  free (ctx);

  return NULL;
}


/************************************************************
 * RESERVE is used to check the syntax of all the variables
 * provided, that the values being set are sensible and consistent,
 * and to allocate any resources required for performing the SET.
 * After this stage, the expectation is that the set ought to
 * succeed, though this is not guaranteed. (In fact, with the UCD
 * agent, this is done in two passes - RESERVE1, and
 * RESERVE2, to allow for dependancies between variables).
 *
 * BEFORE calling this routine, the agent will call duplicate_row
 * to create a copy of the row (unless this is a new row; i.e.
 * row_created == 1).
 *
 * next state -> SET_RESERVE2 || SET_FREE
 */
void
saHpiInventoryTable_set_reserve1 (netsnmp_request_group * rg)
{
  saHpiInventoryTable_context *row_ctx =
    (saHpiInventoryTable_context *) rg->existing_row;

  netsnmp_variable_list *var;
  netsnmp_request_group_item *current;
  int rc;

  DEBUGMSGTL ((AGENT, "saHpiInventoryTable_set_reserve1. Entry\n"));
  for (current = rg->list; current; current = current->next)
    {

      var = current->ri->requestvb;
      rc = SNMP_ERR_NOERROR;

      switch (current->tri->colnum)
	{

	case COLUMN_SAHPIINVENTORYEIRID:
	case COLUMN_SAHPIINVENTORYINDEX:
	case COLUMN_SAHPIINVENTORYRECORDTYPE:
	case COLUMN_SAHPIINVENTORYVALIDITY:
	case COLUMN_SAHPIINVENTORYOEM:
	case COLUMN_SAHPIINVENTORYRDR:
	  rc = SNMP_ERR_NOTWRITABLE;
	  break;
	case COLUMN_SAHPIINVENTORYATTRIBUTES:

	  /** OCTETSTR = ASN_OCTET_STR */
	  if (var->type != ASN_OCTET_STR)
	    {
	      rc = SNMP_ERR_WRONGTYPE;
	    }
	  else if (var->val_len > SAHPI_INVENTORY_ATTRIBUTES_MAX)
	    {
	      rc = SNMP_ERR_WRONGLENGTH;
	    }
	  else if (var->val_len < 0)
	    {
	      rc = SNMP_ERR_WRONGLENGTH;
	    }
	  break;

	case COLUMN_SAHPIINVENTORYTEXTTYPE:
	    /** INTEGER = ASN_INTEGER */
	  rc = netsnmp_check_vb_type_and_size (var, ASN_INTEGER,
					       sizeof (row_ctx->
						       saHpiInventoryTextType));
	  break;

	case COLUMN_SAHPIINVENTORYTEXTLANGUAGE:
	    /** INTEGER = ASN_INTEGER */
	  rc = netsnmp_check_vb_type_and_size (var, ASN_INTEGER,
					       sizeof (row_ctx->
						       saHpiInventoryTextLanguage));
	  break;

	case COLUMN_SAHPIINVENTORYMANUFACTURER:
	case COLUMN_SAHPIINVENTORYPRODUCTNAME:
	case COLUMN_SAHPIINVENTORYPRODUCTVERSION:
	case COLUMN_SAHPIINVENTORYMODELNUMBER:
	case COLUMN_SAHPIINVENTORYSERIALNUMBER:
	case COLUMN_SAHPIINVENTORYPARTNUMBER:
	case COLUMN_SAHPIINVENTORYFILEID:
	case COLUMN_SAHPIINVENTORYASSETTAG:
	case COLUMN_SAHPIINVENTORYCUSTOMFIELD:
	    /** OCTETSTR = ASN_OCTET_STR */
	  if (var->type != ASN_OCTET_STR)
	    {
	      rc = SNMP_ERR_WRONGTYPE;
	    }
	  else if (var->val_len > SAHPI_STRING_MAX)
	    {
	      rc = SNMP_ERR_WRONGLENGTH;
	    }
	  else if (var->val_len < 0)
	    {
	      rc = SNMP_ERR_WRONGLENGTH;
	    }
	  break;

	default:
		/** We shouldn't get here */
	  rc = SNMP_ERR_GENERR;
	  snmp_log (LOG_ERR, "unknown column in "
		    "saHpiInventoryTable_set_reserve1\n");
	}

      if (rc)
	netsnmp_set_mode_request_error (MODE_SET_BEGIN, current->ri, rc);
      rg->status = SNMP_MAX (rg->status, current->ri->status);
    }
  for (current = rg->list; current; current = current->next)
    {

      // The nice thing about this API is that _row_copy() is called
      // for this row - if the API has matched the index with an
      // already existing entry. We check the 'hash' value. If its
      // 0 the API couldn't find the right context.

      if (((saHpiInventoryTable_context *) rg->existing_row)->hash == 0)
	{
	  DEBUGMSGTL ((AGENT, "Asked for non-existing row.\n"));
	  netsnmp_set_mode_request_error (MODE_SET_BEGIN, current->ri,
					  SNMP_ERR_NOSUCHNAME);
	}
      else
	{

	  if (((saHpiInventoryTable_context *) rg->existing_row)->
	      saHpiInventoryValidity == MIB_INVALID)
	    {
	      DEBUGMSGTL ((AGENT,
			   "Row has INVALID flag, thus cannot be modified\n"));
	      netsnmp_set_mode_request_error (MODE_SET_BEGIN, current->ri,
					      SNMP_ERR_NOTWRITABLE);
	    }
	}
    }
  DEBUGMSGTL ((AGENT, "saHpiInventoryTable_set_reserve1. Exit\n"));
}

void
saHpiInventoryTable_set_reserve2 (netsnmp_request_group * rg)
{
  saHpiInventoryTable_context *ctx =
    (saHpiInventoryTable_context *) rg->existing_row;

  netsnmp_request_group_item *current;
  netsnmp_variable_list *var;
  int rc;

  DEBUGMSGTL ((AGENT, "saHpiInventoryTable_set_reserve2. Entry\n"));
  rg->rg_void = rg->list->ri;
  for (current = rg->list; current; current = current->next)
    {

      var = current->ri->requestvb;
      rc = SNMP_ERR_NOERROR;

      switch (current->tri->colnum)
	{

	case COLUMN_SAHPIINVENTORYATTRIBUTES:
	  switch (ctx->saHpiInventoryRecordType-1)
	    {
	    case SAHPI_INVENT_RECTYPE_INTERNAL_USE:
	      if (var->val_len > SAHPI_INVENT_RECTYPE_INTERNAL_USE_MAX)
		rc = SNMP_ERR_WRONGLENGTH;
	      break;
	    case SAHPI_INVENT_RECTYPE_CHASSIS_INFO:
	      if (var->val_len != SAHPI_INVENT_RECTYPE_CHASSIS_INFO_MAX)
		rc = SNMP_ERR_WRONGLENGTH;
	      break;
	    case SAHPI_INVENT_RECTYPE_BOARD_INFO:
	      if (var->val_len != SAHPI_INVENT_RECTYPE_BOARD_INFO_MAX)
		rc = SNMP_ERR_WRONGLENGTH;
	      break;
	    case SAHPI_INVENT_RECTYPE_PRODUCT_INFO:
	      if (var->val_len != SAHPI_INVENT_RECTYPE_PRODUCT_INFO_MAX)
		rc = SNMP_ERR_WRONGLENGTH;
	      break;
	    case SAHPI_INVENT_RECTYPE_OEM:
	      if (var->val_len > SAHPI_INVENT_RECTYPE_OEM_MAX)
		rc = SNMP_ERR_WRONGLENGTH;
	      if (var->val_len < SAHPI_INVENT_RECTYPE_OEM_MIN)
		rc = SNMP_ERR_WRONGLENGTH;
	      break;
	    default:
	      // Means that VALIDITY flag is set to INVALID.          
	      rc = SNMP_ERR_INCONSISTENTVALUE;
	      break;
	    }
	  break;

	case COLUMN_SAHPIINVENTORYTEXTTYPE:
	  switch (ctx->saHpiInventoryRecordType-1)
	    {
	    case SAHPI_INVENT_RECTYPE_CHASSIS_INFO:
	    case SAHPI_INVENT_RECTYPE_BOARD_INFO:
	    case SAHPI_INVENT_RECTYPE_PRODUCT_INFO:
	      // Not include undefined(0) since its non-compliant.
	      if (((*var->val.integer < 1) || (*var->val.integer > 4)))
		{
		  rc = SNMP_ERR_BADVALUE;
		}
	      break;
	    default:
	      // Wrong type.
	      rc = SNMP_ERR_INCONSISTENTVALUE;
	      break;
	    }
	  break;
	case COLUMN_SAHPIINVENTORYTEXTLANGUAGE:
	  switch (ctx->saHpiInventoryRecordType-1)
	    {
	    case SAHPI_INVENT_RECTYPE_CHASSIS_INFO:
	    case SAHPI_INVENT_RECTYPE_BOARD_INFO:
	    case SAHPI_INVENT_RECTYPE_PRODUCT_INFO:
	      if (((*var->val.integer < 1) || (*var->val.integer > 137)))
		{
		  rc = SNMP_ERR_BADVALUE;
		}
	      break;
	    default:
	      // Wrong type.
	      rc = SNMP_ERR_INCONSISTENTVALUE;
	      break;

	    }
	  break;

	case COLUMN_SAHPIINVENTORYMANUFACTURER:
	case COLUMN_SAHPIINVENTORYPRODUCTNAME:
	case COLUMN_SAHPIINVENTORYPRODUCTVERSION:
	case COLUMN_SAHPIINVENTORYMODELNUMBER:
	case COLUMN_SAHPIINVENTORYSERIALNUMBER:
	case COLUMN_SAHPIINVENTORYPARTNUMBER:
	case COLUMN_SAHPIINVENTORYFILEID:
	case COLUMN_SAHPIINVENTORYASSETTAG:
	case COLUMN_SAHPIINVENTORYCUSTOMFIELD:
	  switch (ctx->saHpiInventoryRecordType-1)
	    {
	    case SAHPI_INVENT_RECTYPE_CHASSIS_INFO:
	      break;
	    case SAHPI_INVENT_RECTYPE_BOARD_INFO:
	      break;
	    case SAHPI_INVENT_RECTYPE_PRODUCT_INFO:
	      break;
	    default:
	      // Wrong type.
	      rc = SNMP_ERR_INCONSISTENTVALUE;
	      break;
	    }
	  break;
	default:
		/** We shouldn't get here */
	  netsnmp_assert (0);/** why wasn't this caught in reserve1? */
	  break;
	}

      if (rc)
	netsnmp_set_mode_request_error (MODE_SET_BEGIN, current->ri, rc);
    }
  DEBUGMSGTL ((AGENT, "saHpiInventoryTable_set_reserve2. Exit\n"));
}

/************************************************************
 * Assuming that the RESERVE phases were successful, the next
 * stage is indicated by the action value ACTION. This is used
 * to actually implement the set operation. However, this must
 * either be done into temporary (persistent) storage, or the
 * previous value stored similarly, in case any of the subsequent
 * ACTION calls fail.
 *
 * In your case, changes should be made to row_ctx. A copy of
 * the original row is in undo_ctx.
 */
void
saHpiInventoryTable_set_action (netsnmp_request_group * rg)
{
  netsnmp_variable_list *var;
  saHpiInventoryTable_context *row_ctx =
    (saHpiInventoryTable_context *) rg->existing_row;
  //    saHpiInventoryTable_context *undo_ctx =
  //  (saHpiInventoryTable_context *) rg->undo_info;
  netsnmp_request_group_item *current;
  int err = AGENT_ERR_NOERROR;
  int rc = SNMP_ERR_NOERROR;
  DEBUGMSGTL ((AGENT, "saHpiInventoryTable_set_action. Entry\n"));
  for (current = rg->list; current; current = current->next)
    {

      var = current->ri->requestvb;

      switch (current->tri->colnum)
	{

	case COLUMN_SAHPIINVENTORYATTRIBUTES:
	    /** OCTETSTR = ASN_OCTET_STR */
	  memcpy (row_ctx->saHpiInventoryAttributes, var->val.string,
		  var->val_len);
	  row_ctx->saHpiInventoryAttributes_len = var->val_len;
	  break;

	case COLUMN_SAHPIINVENTORYTEXTTYPE:
	    /** INTEGER = ASN_INTEGER */
	  row_ctx->saHpiInventoryTextType = *var->val.integer;
	  break;

	case COLUMN_SAHPIINVENTORYTEXTLANGUAGE:
	    /** INTEGER = ASN_INTEGER */
	  row_ctx->saHpiInventoryTextLanguage = *var->val.integer;
	  break;

	case COLUMN_SAHPIINVENTORYMANUFACTURER:
	    /** OCTETSTR = ASN_OCTET_STR */
	  memcpy (row_ctx->saHpiInventoryManufacturer, var->val.string,
		  var->val_len);
	  row_ctx->saHpiInventoryManufacturer_len = var->val_len;
	  break;

	case COLUMN_SAHPIINVENTORYPRODUCTNAME:
	    /** OCTETSTR = ASN_OCTET_STR */
	  memcpy (row_ctx->saHpiInventoryProductName, var->val.string,
		  var->val_len);
	  row_ctx->saHpiInventoryProductName_len = var->val_len;
	  break;

	case COLUMN_SAHPIINVENTORYPRODUCTVERSION:
	    /** OCTETSTR = ASN_OCTET_STR */
	  memcpy (row_ctx->saHpiInventoryProductVersion, var->val.string,
		  var->val_len);
	  row_ctx->saHpiInventoryProductVersion_len = var->val_len;
	  break;

	case COLUMN_SAHPIINVENTORYMODELNUMBER:
	    /** OCTETSTR = ASN_OCTET_STR */
	  memcpy (row_ctx->saHpiInventoryModelNumber, var->val.string,
		  var->val_len);
	  row_ctx->saHpiInventoryModelNumber_len = var->val_len;
	  break;

	case COLUMN_SAHPIINVENTORYSERIALNUMBER:
	    /** OCTETSTR = ASN_OCTET_STR */
	  memcpy (row_ctx->saHpiInventorySerialNumber, var->val.string,
		  var->val_len);
	  row_ctx->saHpiInventorySerialNumber_len = var->val_len;
	  break;

	case COLUMN_SAHPIINVENTORYPARTNUMBER:
	    /** OCTETSTR = ASN_OCTET_STR */
	  memcpy (row_ctx->saHpiInventoryPartNumber, var->val.string,
		  var->val_len);
	  row_ctx->saHpiInventoryPartNumber_len = var->val_len;
	  break;

	case COLUMN_SAHPIINVENTORYFILEID:
	    /** OCTETSTR = ASN_OCTET_STR */
	  memcpy (row_ctx->saHpiInventoryFileId, var->val.string,
		  var->val_len);
	  row_ctx->saHpiInventoryFileId_len = var->val_len;
	  break;

	case COLUMN_SAHPIINVENTORYASSETTAG:
	    /** OCTETSTR = ASN_OCTET_STR */
	  memcpy (row_ctx->saHpiInventoryAssetTag, var->val.string,
		  var->val_len);
	  row_ctx->saHpiInventoryAssetTag_len = var->val_len;
	  break;

	case COLUMN_SAHPIINVENTORYCUSTOMFIELD:
	    /** OCTETSTR = ASN_OCTET_STR */
	  memcpy (row_ctx->saHpiInventoryCustomField, var->val.string,
		  var->val_len);
	  row_ctx->saHpiInventoryCustomField_len = var->val_len;
	  break;

	default:
		/** We shouldn't get here */
	  netsnmp_assert (0);  /** why wasn't this caught in reserve1? */
	}

      err = set_inventory (row_ctx);
      if (err == AGENT_ERR_MEMORY_FAULT)
	rc = SNMP_ERR_RESOURCEUNAVAILABLE;
      else if (err != AGENT_ERR_NOERROR)
	rc = SNMP_ERR_GENERR;

      if (rc)
	netsnmp_set_mode_request_error (MODE_SET_BEGIN, current->ri, rc);
    }
  DEBUGMSGTL ((AGENT, "saHpiInventoryTable_set_action. Exit\n"));
}

/************************************************************
 * Only once the ACTION phase has completed successfully, can
 * the final COMMIT phase be run. This is used to complete any
 * writes that were done into temporary storage, and then release
 * any allocated resources. Note that all the code in this phase
 * should be "safe" code that cannot possibly fail (cue
 * hysterical laughter). The whole intent of the ACTION/COMMIT
 * division is that all of the fallible code should be done in
 * the ACTION phase, so that it can be backed out if necessary.
 *
 * BEFORE calling this routine, the agent will update the
 * container (inserting a row if row_created == 1, or removing
 * the row if row_deleted == 1).
 *
 * AFTER calling this routine, the agent will delete the
 * undo_info.
 */
void
saHpiInventoryTable_set_commit (netsnmp_request_group * rg)
{

}

/************************************************************
 * If either of the RESERVE calls fail, the write routines
 * are called again with the FREE action, to release any resources
 * that have been allocated. The agent will then return a failure
 * response to the requesting application.
 *
 * AFTER calling this routine, the agent will delete undo_info.
 */
void
saHpiInventoryTable_set_free (netsnmp_request_group * rg)
{

}

/************************************************************
 * If the ACTION phase does fail (for example due to an apparently
 * valid, but unacceptable value, or an unforeseen problem), then
 * the list of write routines are called again, with the UNDO
 * action. This requires the routine to reset the value that was
 * changed to its previous value (assuming it was actually changed),
 * and then to release any resources that had been allocated. As
 * with the FREE phase, the agent will then return an indication
 * of the error to the requesting application.
 *
 * BEFORE calling this routine, the agent will update the container
 * (remove any newly inserted row, re-insert any removed row).
 *
 * AFTER calling this routing, the agent will call row_copy
 * to restore the data in existing_row from the date in undo_info.
 * Then undo_info will be deleted (or existing row, if row_created
 * == 1).
 */
void
saHpiInventoryTable_set_undo (netsnmp_request_group * rg)
{

}




/************************************************************
 *
 * Initialize the saHpiInventoryTable table by defining its contents and how it's structured
 */
void
initialize_table_saHpiInventoryTable (void)
{
  netsnmp_table_registration_info *table_info;

  if (my_handler)
    {
      snmp_log (LOG_ERR,
		"initialize_table_saHpiInventoryTable_handler called again\n");
      return;
    }

  memset (&cb, 0x00, sizeof (cb));

    /** create the table structure itself */
  table_info = SNMP_MALLOC_TYPEDEF (netsnmp_table_registration_info);

  /*
   * if your table is read only, it's easiest to change the
   * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
   */
  my_handler = netsnmp_create_handler_registration ("saHpiInventoryTable",
						    netsnmp_table_array_helper_handler,
						    saHpiInventoryTable_oid,
						    saHpiInventoryTable_oid_len,
						    HANDLER_CAN_RWRITE);

  if (!my_handler || !table_info)
    {
      snmp_log (LOG_ERR, "malloc failed in "
		"initialize_table_saHpiInventoryTable_handler\n");
      return;	/** mallocs failed */
    }

    /***************************************************
     * Setting up the table's definition
     */


  /*
   * internal indexes
   */

  // INVENTORY_INDEX_NR 
  netsnmp_table_helper_add_index (table_info, ASN_UNSIGNED);
  netsnmp_table_helper_add_index (table_info, ASN_UNSIGNED);
  netsnmp_table_helper_add_index (table_info, ASN_UNSIGNED);
  netsnmp_table_helper_add_index (table_info, ASN_UNSIGNED);

  table_info->min_column = saHpiInventoryTable_COL_MIN;
  table_info->max_column = saHpiInventoryTable_COL_MAX;

    /***************************************************
     * registering the table with the master agent
     */
  cb.get_value = saHpiInventoryTable_get_value;
  cb.container = netsnmp_container_find ("saHpiInventoryTable_primary:"
					 "saHpiInventoryTable:"
					 "table_container");




  //cb.can_set = 1;

  cb.create_row = (UserRowMethod *) saHpiInventoryTable_create_row;


  cb.duplicate_row = (UserRowMethod *) saHpiInventoryTable_duplicate_row;
  cb.delete_row = (UserRowMethod *) saHpiInventoryTable_delete_row;
  cb.row_copy = (Netsnmp_User_Row_Operation *) saHpiInventoryTable_row_copy;

  cb.can_delete = (Netsnmp_User_Row_Action *) saHpiInventoryTable_can_delete;

  cb.set_reserve1 = saHpiInventoryTable_set_reserve1;
  cb.set_reserve2 = saHpiInventoryTable_set_reserve2;
  cb.set_action = saHpiInventoryTable_set_action;
  cb.set_commit = saHpiInventoryTable_set_commit;
  cb.set_free = saHpiInventoryTable_set_free;
  cb.set_undo = saHpiInventoryTable_set_undo;

  DEBUGMSGTL (("initialize_table_saHpiInventoryTable",
	       "Registering table saHpiInventoryTable "
	       "as a table array\n"));

  netsnmp_table_container_register (my_handler, table_info, &cb,
				    cb.container, 1);

  netsnmp_register_read_only_counter32_instance ("inventory_count",
						 saHpiInventoryCount_oid,
						 OID_LENGTH
						 (saHpiInventoryCount_oid),
						 &inventory_count, NULL);
}

/************************************************************
 * saHpiInventoryTable_get_value
 */
int
saHpiInventoryTable_get_value (netsnmp_request_info * request,
			       netsnmp_index * item,
			       netsnmp_table_request_info * table_info)
{
  netsnmp_variable_list *var = request->requestvb;
  saHpiInventoryTable_context *context = (saHpiInventoryTable_context *) item;

  switch (table_info->colnum)
    {

    case COLUMN_SAHPIINVENTORYEIRID:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->saHpiInventoryEirId,
				sizeof (context->saHpiInventoryEirId));
      break;

    case COLUMN_SAHPIINVENTORYINDEX:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->saHpiInventoryIndex,
				sizeof (context->saHpiInventoryIndex));
      break;

    case COLUMN_SAHPIINVENTORYRECORDTYPE:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiInventoryRecordType,
				sizeof (context->saHpiInventoryRecordType));
      break;

    case COLUMN_SAHPIINVENTORYVALIDITY:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->saHpiInventoryValidity,
				sizeof (context->saHpiInventoryValidity));
      break;

    case COLUMN_SAHPIINVENTORYATTRIBUTES:
	    /** OCTETSTR = ASN_OCTET_STR */
      snmp_set_var_typed_value (var, ASN_OCTET_STR,
				(char *) &context->
				saHpiInventoryAttributes,
				context->saHpiInventoryAttributes_len);
      break;

    case COLUMN_SAHPIINVENTORYTEXTTYPE:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->saHpiInventoryTextType,
				sizeof (context->saHpiInventoryTextType));
      break;

    case COLUMN_SAHPIINVENTORYTEXTLANGUAGE:
	    /** INTEGER = ASN_INTEGER */
      snmp_set_var_typed_value (var, ASN_INTEGER,
				(char *) &context->
				saHpiInventoryTextLanguage,
				sizeof (context->saHpiInventoryTextLanguage));
      break;

    case COLUMN_SAHPIINVENTORYMANUFACTURER:
	    /** OCTETSTR = ASN_OCTET_STR */
      snmp_set_var_typed_value (var, ASN_OCTET_STR,
				(char *) &context->
				saHpiInventoryManufacturer,
				context->saHpiInventoryManufacturer_len);
      break;

    case COLUMN_SAHPIINVENTORYPRODUCTNAME:
	    /** OCTETSTR = ASN_OCTET_STR */
      snmp_set_var_typed_value (var, ASN_OCTET_STR,
				(char *) &context->
				saHpiInventoryProductName,
				context->saHpiInventoryProductName_len);
      break;

    case COLUMN_SAHPIINVENTORYPRODUCTVERSION:
	    /** OCTETSTR = ASN_OCTET_STR */
      snmp_set_var_typed_value (var, ASN_OCTET_STR,
				(char *) &context->
				saHpiInventoryProductVersion,
				context->saHpiInventoryProductVersion_len);
      break;

    case COLUMN_SAHPIINVENTORYMODELNUMBER:
	    /** OCTETSTR = ASN_OCTET_STR */
      snmp_set_var_typed_value (var, ASN_OCTET_STR,
				(char *) &context->
				saHpiInventoryModelNumber,
				context->saHpiInventoryModelNumber_len);
      break;

    case COLUMN_SAHPIINVENTORYSERIALNUMBER:
	    /** OCTETSTR = ASN_OCTET_STR */
      snmp_set_var_typed_value (var, ASN_OCTET_STR,
				(char *) &context->
				saHpiInventorySerialNumber,
				context->saHpiInventorySerialNumber_len);
      break;

    case COLUMN_SAHPIINVENTORYPARTNUMBER:
	    /** OCTETSTR = ASN_OCTET_STR */
      snmp_set_var_typed_value (var, ASN_OCTET_STR,
				(char *) &context->
				saHpiInventoryPartNumber,
				context->saHpiInventoryPartNumber_len);
      break;

    case COLUMN_SAHPIINVENTORYFILEID:
	    /** OCTETSTR = ASN_OCTET_STR */
      snmp_set_var_typed_value (var, ASN_OCTET_STR,
				(char *) &context->saHpiInventoryFileId,
				context->saHpiInventoryFileId_len);
      break;

    case COLUMN_SAHPIINVENTORYASSETTAG:
	    /** OCTETSTR = ASN_OCTET_STR */
      snmp_set_var_typed_value (var, ASN_OCTET_STR,
				(char *) &context->saHpiInventoryAssetTag,
				context->saHpiInventoryAssetTag_len);
      break;

    case COLUMN_SAHPIINVENTORYCUSTOMFIELD:
	    /** OCTETSTR = ASN_OCTET_STR */
      snmp_set_var_typed_value (var, ASN_OCTET_STR,
				(char *) &context->
				saHpiInventoryCustomField,
				context->saHpiInventoryCustomField_len);
      break;

    case COLUMN_SAHPIINVENTORYOEM:
	    /** UNSIGNED32 = ASN_UNSIGNED */
      snmp_set_var_typed_value (var, ASN_UNSIGNED,
				(char *) &context->saHpiInventoryOEM,
				sizeof (context->saHpiInventoryOEM));
      break;

    case COLUMN_SAHPIINVENTORYRDR:
	    /** RowPointer = ASN_OBJECT_ID */
      snmp_set_var_typed_value (var, ASN_OBJECT_ID,
				(char *) &context->saHpiInventoryRDR,
				context->saHpiInventoryRDR_len);
      break;

    default:
	    /** We shouldn't get here */
      snmp_log (LOG_ERR, "unknown column in "
		"saHpiInventoryTable_get_value\n");
      return SNMP_ERR_GENERR;
    }
  return SNMP_ERR_NOERROR;
}
