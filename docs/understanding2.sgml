<!-- ...................................................................... -->
<!-- $Id$ ................................................ -->
<!-- 
        This material may be distributed only subject to the terms and 
        conditions set forth in the Open Publication License, v1.0 or later 
        (the latest version is currently available at 
        http://www.opencontent.org/openpub/).  Distribution of substantively 
        modified version of this document is prohibited without the explicit 
        permission of the copyright holder.

        Other company, product, or service names may be trademarks or service 
        marks of others.
-->
<chapter>
    <title>Header file</title>
    <sect1>
    <title>Header files</title>
    <para>
	The header file generated by the 'mib2c' tool consist of
	five elements:
    </para>
	<itemizedlist mark='opencircle'>
	  <listitem>
	  	<para>A <emphasis>context</emphasis> structure. It is a
	     	one to one mapping of the leaf nodes (columnar objects) 
		in a SEQUENCE table to a C structure, with the first variable
		being the index tuple.
	 	</para>
	  </listitem>
	  <listitem>
	  	<para>
		Functions for manipulating the <emphasis>context</emphasis> structure.
		These include generic functions for sorting, getting an item, checking for
		correct boundary conditions, and generating the index tuple.
		</para>
	  <listitem>
	  	<para>
		Object IDentifier for the table.
		</para>
	  </listitem>
	  <listitem>
	  	<para>
		Textual names of the leaf nodes (columnar objects) using #define.
		</para>
	  </listitem>
	  <listitem>
	  	<para>
		Different #define enabling/disabling different functions of the 
		sub-agent table manipulations.
		</para>
	  </listitem>
	</itemizedlist>
    <sect2>
      <title>Context structure</title>
      <para>
      The <emphasis>context</emphasis> structure is used exclusivly by the NetSNMP API
      for manipulating rows of leaf nodes (columnar objects).
      </para>
      <para>
      The first named variables of the structure is
	<programlisting role='C'>
      typedef struct netSnmpIETFWGTable_context_s {
    	netsnmp_index index; /** THIS MUST BE FIRST!!! */
	....
      </programlisting>
      <para>The <emphasis>netsnmp_index</emphasis> is defined in <emphasis>net-snmp/types.h</emphasis> as
      </para>
      	<programlisting role="C">
    typedef struct netsnmp_index_s {
       int          len;
       oid         *oids;
    } netsnmp_index;
	</programlisting>
       <para>
       	The <emphasis>oid</emphasis> is defined as unsigned long  (look in net-snmp/library/asn1.h).
	The <emphasis>len</emphasis> is the number of entries in the array at *oids, 
	<emphasis>not</emphasis> the length of the OID in the bytes.
       </para>
       <para>
       	This <emphasis>netsnmp_index</emphasis> structure is used to place the index tuple
	of the row. Not the full OID (as in fully expanded OID of the table), but just 
	the sub-set of numbers uniquely defining the row.
       </para> 
       <sect3>
        <title>Example of using netsnmp_index</title>
	<para>
	 The example uses the IETF WG table structure to set the index tuple to the string
	 "fodo."
	 </para>
	 <programlisting role='C'>
	  netsnmp_index *index;
	  oid index_oid[5];

	  index = SNMP_MALLOC_TYPEDEF(netsnmp_index);
	  index_oid[0] = 4;  // The first value is the length of the string. 
	  index_oid[1] ='f'; 
	  index_oid[2] ='o'; 
	  index_oid[3] ='d';
	  index_oid[4] ='o';

	  index->oids = index_oid;
	  index->len = 5;
	</programlisting>	
	<para>
	This example will generate the index tuple, nothing else. 
	The rest of the generated structure contains  columnar
	(leaf nodes) mapped to C types. The generator assumes the most
	general type - therefore a <emphasis>TruthValue</emphasis> textual 
	convention in a MIB will map to an ASN_INTEGER type - in C language
	this will be <emphasis>unsigned long</emphasis>. 
	</para>
	<para>
	The length of the data (if the columnar node is defined as <emphasis>
	OCTET STRING(SIZE(1..10))</emphasis> is NOT taken under consideration
	and has to be manually changed from the maximum length.
	</para>
	<para>
	Subsequent examples will demonstrate how to fully leverage the rest of 
	the context structure.
	</para>
       </sect3>
      </sect2>
      <sect2>
      	<title>Functions</title>
	<para>
	  The 'mib2c' places the function prototypes right behind the
	  context structure and also behind the textual names of the leaf nodes.
	</para>
	<programlisting role='C'>
void init_netSnmpIETFWGTable(void);
void initialize_table_netSnmpIETFWGTable(void);
const netSnmpIETFWGTable_context * netSnmpIETFWGTable_get_by_idx(netsnmp_index *);
const netSnmpIETFWGTable_context * netSnmpIETFWGTable_get_by_idx_rs(netsnmp_index *,
                                        int row_status);
int netSnmpIETFWGTable_get_value(netsnmp_request_info *, netsnmp_index *, netsnmp_table_request_info *);
	</programlisting>
	<para>
	  The first set of declared functions are used to:
	</para>
	<itemizedlist mark='closedcircle'>
	   <listitem>
	   	<para>
		  Initialize the table. This function will be fully explained 
		  in the subsequent sections.
		</para>
	   </listitem>
	   <listitem>
	   	<para>
		  Helper functions for retrieving the index value. This might sound 
		  like an oxymoron - does not the first value of the <emphasis>
		  context</emphasis> structure contain the index value? Yes, but what
		  if that value is dynamic and depends on external data-sources? 
		 </para>
		 <para>
		   This function allows for the sub-agent to check 
		   (or reshape) of the column objects in a row before delievering
		   to the user.
		 </para>
		 <warning>
		   <para>
		   This function will not be discussed in this tutorial.
		   </para>
		 </warning>
	    </listitem>
	    <listitem>
	    	 <para>
		  Helper functions for retrieving the data value of the columnar object
		  in a specific row. The column number, and row is passed in to this
		  function.
		 </para>
	     </listitem>
	   </itemizedlist>
	   <para>
	    The next set of functions are controlled by a set of #define statements. 
	    These operations are for writing, deleting, creating, and retrieving secondary index 
	    off rows. 
<programlisting role='C'>
#ifdef netSnmpIETFWGTable_SET_HANDLING

int netSnmpIETFWGTable_extract_index( netSnmpIETFWGTable_context * ctx, netsnmp_index * hdr );

void netSnmpIETFWGTable_set_reserve1( netsnmp_request_group * );
void netSnmpIETFWGTable_set_reserve2( netsnmp_request_group * );
void netSnmpIETFWGTable_set_action( netsnmp_request_group * );
void netSnmpIETFWGTable_set_commit( netsnmp_request_group * );
void netSnmpIETFWGTable_set_free( netsnmp_request_group * );
void netSnmpIETFWGTable_set_undo( netsnmp_request_group * );

netSnmpIETFWGTable_context * netSnmpIETFWGTable_duplicate_row( netSnmpIETFWGTable_context* );
netsnmp_index * netSnmpIETFWGTable_delete_row( netSnmpIETFWGTable_context* );

int netSnmpIETFWGTable_can_delete(netSnmpIETFWGTable_context *undo_ctx,
                    netSnmpIETFWGTable_context *row_ctx,
                    netsnmp_request_group * rg);
    
    
#ifdef netSnmpIETFWGTable_ROW_CREATION
netSnmpIETFWGTable_context * netSnmpIETFWGTable_create_row( netsnmp_index* );
#endif
#endif

#ifdef netSnmpIETFWGTable_IDX2
netSnmpIETFWGTable_context * netSnmpIETFWGTable_get( const char *name, int len );
#endif
</programlisting>
	   <para>
	    There are three sets of functions:
	   </para>
	    <itemizedlist>
		<listitem>
		  <para>
		     For SNMP SET operations. These operations are used to write and delete
		     (if appropiate) rows.
		  </para>
		 </listitem>
		 <listitem>
		   <para>
		     For creation of rows.
		   </para>
		  </listitem>
		  <listitem>
		    <para>
		      Manipulating secondary (or more) index tuple.
		    </para>
		  </listitem>
	    </itemizedlist>
     <sect2>
      <title>Object IDentifier of the table</title>
      <para>
       The 'mib2c' tool also extracts the OID of the table. This sequence of numbers
       is when the sub-agent registers the table.
      </para>
     </sect2>

     <sect2>
      <title>Textual names for leaf nodes</title>
      <para>
       The leaf nodes object names (from the MIB) are translated to a
       list of #define in the format of:
      </para>
      <para>
        #define COLUMN_&lt;name of the leaf node&gt; &lt;columnar index value&gt;
      </para>
      <para>
       for each of the leaf nodes.
      </para>
      <programlisting role='C'>
#define COLUMN_NSIETFWGNAME 1
#define COLUMN_NSIETFWGCHAIR1 2
#define COLUMN_NSIETFWGCHAIR2 3      
      </programlisting>
      <para>
      	These textual names are used in the generated C source code instead of 
	just the numerical values.
      </para>
     </sect2>

     <sect2>
      <title>Enabling and disabling of operations</title>
      <para>
       The three set of #define statements disable or enable sub-agent operations.
      </para>
      <itemizedlist>
        <listitem>
	  <para>Commenting out <emphasis>netSnmpIETFWGTable_SET_HANDLING</emphasis> 
	  will make the sub-agent not handle SNMP SET requests.
	  </para>
	</listitem>
	<listitem>
	  <para>Commenting out <emphasis>netSnmpIETFWGTable_ROW_CREATION</emphasis>
	  will not allow the sub-agent to create rows.
	  </para>
	</listitem>
	<listitem>
	  <para>Commenting out <emphasis>netSnmpIETFWGTable_IDX2</emphasis> disables
	  the handling of secondary (or more) of index.
	  </para>
	 </listitem>
      </itemizedlist>
	<para>These #define statements also exist in the generated C source code
	to properly disable/enable certain functions. For the purpose of this
	tutorial assume that all of the #define have to be in place.
	</para>
    </sect2>
  </sect1>	
</chapter>
